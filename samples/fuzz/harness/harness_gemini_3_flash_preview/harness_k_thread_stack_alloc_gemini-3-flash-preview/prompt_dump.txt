==== SYSTEM PROMPT ====
You are a Zephyr kernel and driver-level testing expert. Generate high-quality, compilable, and runnable fuzzing test cases for the target API. Ensure task lifecycle completeness, correct synchronization usage, memory safety, and minimal viable initialization. The harness template already provides a fixed skeleton: it reads fuzz input via FR_* helpers from the global FUZZ_INPUT array, runs test logic inside a bounded for-loop, then prints [TEST_CASE_COMPLETED] and triggers a BREAKPOINT. Your job is ONLY to generate per-test-case helper_functions and test_logic bodies that plug into this skeleton. Target environment: Zephyr RTOS (mps2/an385, QEMU). Single-threaded execution.
Constraints:
1. Concurrency: **NO BLOCKING CALLS** on IPC/Sync objects (Pipe, MsgQ, Sem). This causes DEADLOCK in single-threaded tests. **ALWAYS use K_NO_WAIT** for reads/takes.
2. APIs: Prefer public `k_*` APIs. Avoid internal `z_*` symbols.
3. Memory: Static allocation preferred. No leaks.
4. Flow: No infinite loops. `test_logic` runs inside a bounded loop.
Input Policy: Use ONLY provided `FR_*` helpers to read from global `FUZZ_INPUT`. Deterministic mapping only (no rand/time).
Helper Signatures:
FR_Reader FR_init(const unsigned char* buf, size_t n); // Usage: FR_init(FUZZ_INPUT, MAX_FUZZ_INPUT_SIZE)
FR_next_range(FR_Reader* r, uint32_t min, uint32_t max) -> uint32_t;
FR_next_bytes(FR_Reader* r, unsigned char* out, size_t n) -> size_t;
FR_next_string(FR_Reader* r, size_t max_len) -> const char*;
Use modulo/clamping for valid ranges. `test_logic` runs in a bounded loop. NO infinite loops.
Reader Discipline: Init `FR_Reader` ONCE outside loop. Check `FR_remaining`.

==== USER PROMPT ====
Goal: Generate 1 fuzzing test case (JSON array) for the functions below and their key related APIs. Each item must include: name, description, api_category, helper_functions, test_logic.
Focus functions: k_thread_stack_alloc, k_queue_peek_head, k_thread_stack_free, K_THREAD_STACK_DEFINE, K_THREAD_STACK_DECLARE

### Function k_thread_stack_alloc
Signature: k_thread_stack_t * k_thread_stack_alloc ( size_t size, int flags );
Location: 
Cyclomatic: None Lines: None
Includes: none
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Parameters:
- size: size_t — Stack size in bytes.
- flags: int — Stack creation flags, or 0.
Return values:
- : allocated thread stack on success.
- : on failure.
- : 
- : 
Related configs: none
Related APIs: none
Reference snippets:
- k_thread_stack_alloc (api:k_thread_stack_alloc:overview#c0) :: API: k_thread_stack_alloc Signature: k_thread_stack_t * k_thread_stack_alloc ( size_t size, int flags );
- K_THREAD_STACK_DEFINE (api:K_THREAD_STACK_DEFINE:overview#c0) :: API: K_THREAD_STACK_DEFINE Signature:
- K_THREAD_STACK_DECLARE (api:K_THREAD_STACK_DECLARE:overview#c0) :: API: K_THREAD_STACK_DECLARE Signature:
- k_thread_stack_alloc (api:k_thread_stack_alloc:parameters#c0) :: API: k_thread_stack_alloc Section: parameters param size: size_t Stack size in bytes. param flags: int Stack creation flags, or 0.
- k_stack_alloc_init (api:k_stack_alloc_init:overview#c0) :: API: k_stack_alloc_init Signature: int32_t k_stack_alloc_init ( struct k_stack * stack, uint32_t num_entries );
- Call z_impl_k_stack_alloc_init -> z_thread_malloc (edge:z_impl_k_stack_alloc_init->z_thread_malloc:kernel/stack.c:51#c0) :: Call: z_impl_k_stack_alloc_init -> z_thread_malloc at kernel/stack.c:51

Official documentation (full):
Title: k_thread_stack_alloc
Signature: k_thread_stack_t * k_thread_stack_alloc ( size_t size, int flags );
Parameters:
- size: size_t — Stack size in bytes.
- flags: int — Stack creation flags, or 0.
Return values:
- : allocated thread stack on success.
- : on failure.
- : 
- : 

### Function k_queue_peek_head
Signature: void * k_queue_peek_head ( struct k_queue * queue );
Location: 
Cyclomatic: None Lines: None
Includes: none
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Parameters:
- queue: struct k_queue * — Address of the queue.
Return values:
- : Head element, or NULL if queue is empty.
Related configs: none
Related APIs: none

Official documentation (full):
Title: k_queue_peek_head
Signature: void * k_queue_peek_head ( struct k_queue * queue );
Parameters:
- queue: struct k_queue * — Address of the queue.
Return values:
- : Head element, or NULL if queue is empty.

### Function k_thread_stack_free
Signature: int k_thread_stack_free ( k_thread_stack_t * stack );
Location: 
Cyclomatic: None Lines: None
Includes: none
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Parameters:
- stack: k_thread_stack_t * — Pointer to the thread stack.
Return values:
- : on success.
- : if the thread stack is in use.
- : if stack is invalid.
- : if dynamic thread stack allocation is disabled
Related configs: none
Related APIs: none

Official documentation (full):
Title: k_thread_stack_free
Signature: int k_thread_stack_free ( k_thread_stack_t * stack );
Parameters:
- stack: k_thread_stack_t * — Pointer to the thread stack.
Return values:
- : on success.
- : if the thread stack is in use.
- : if stack is invalid.
- : if dynamic thread stack allocation is disabled

### Function K_THREAD_STACK_DEFINE
Signature: #define K_THREAD_STACK_DEFINE ( sym, size )
Location: 
Cyclomatic: None Lines: None
Includes: #include <zephyr/kernel/thread_stack.h>
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Related configs: none
Related APIs: none
Reference snippets:
- K_THREAD_STACK_DEFINE (api:K_THREAD_STACK_DEFINE:overview#c0) :: API: K_THREAD_STACK_DEFINE Signature:

Official documentation (full):
Title: K_THREAD_STACK_DEFINE
Definition: #define K_THREAD_STACK_DEFINE ( sym, size )
Includes:
#include <zephyr/kernel/thread_stack.h>
Details (truncated):
Z_THREAD_STACK_DEFINE_IN(sym, size, __stackmem) Define a toplevel thread stack memory region.
This defines a region of memory suitable for use as a thread's stack.
This is the generic, historical definition. Align to Z_THREAD_STACK_OBJ_ALIGN and put in 'noinit' section so that it isn't zeroed at boot The defined symbol will always be a k_thread_stack_t which can be passed to k_thread_create(), but should otherwise not be manipulated. If the buffer inside needs to be examined, examine thread->stack_info for the associated thread object to obtain the boundaries.
It is legal to precede this definition with the 'static' keyword.
It is NOT legal to take the sizeof(sym) and pass that to the stackSize parameter of k_thread_create(), it may not be the same as the 'size' parameter. Use K_THREAD_STACK_SIZEOF() instead.
Some arches may round the size of the usable stack region up to satisfy alignment constraints. K_THREAD_STACK_SIZEOF() will return the aligned size.

### Function K_THREAD_STACK_DECLARE
Signature: #define K_THREAD_STACK_DECLARE ( sym, size )
Location: 
Cyclomatic: None Lines: None
Includes: #include <zephyr/kernel/thread_stack.h>
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Related configs: none
Related APIs: none
Reference snippets:
- K_THREAD_STACK_DECLARE (api:K_THREAD_STACK_DECLARE:overview#c0) :: API: K_THREAD_STACK_DECLARE Signature:

Official documentation (full):
Title: K_THREAD_STACK_DECLARE
Definition: #define K_THREAD_STACK_DECLARE ( sym, size )
Includes:
#include <zephyr/kernel/thread_stack.h>
Details (truncated):
extern struct z_thread_stack_element sym[K_THREAD_STACK_LEN(size)] Declare a reference to a thread stack.
This macro declares the symbol of a thread stack defined elsewhere in the current scope.

Generation requirements (Zephyr):
1) Output strict JSON array.
2) `test_logic` must be non-blocking (use `K_NO_WAIT` to prevent deadlock).
3) Derive parameters from `FUZZ_INPUT` using `FR_*` helpers.
4) Use `__ASSERT` for checks. Clean up on failure.
5) Choose suitable `api_category`.9) JSON formatting MUST be valid: use double quotes, escape all newline characters as \n, and do NOT include code fences/backticks. No trailing commas.

Forbidden/limitations (Zephyr):
- Do NOT call Zephyr internal/private symbols (e.g., names starting with z_ or arch_).
- Do NOT include random(), srand(), time(), or platform-specific syscalls. All variability from FUZZ_INPUT.
- Do NOT define any symbols with FR_ prefix; these are reserved by the template.
