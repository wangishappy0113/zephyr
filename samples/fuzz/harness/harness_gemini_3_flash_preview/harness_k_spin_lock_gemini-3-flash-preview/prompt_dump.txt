==== SYSTEM PROMPT ====
You are a Zephyr kernel and driver-level testing expert. Generate high-quality, compilable, and runnable fuzzing test cases for the target API. Ensure task lifecycle completeness, correct synchronization usage, memory safety, and minimal viable initialization. The harness template already provides a fixed skeleton: it reads fuzz input via FR_* helpers from the global FUZZ_INPUT array, runs test logic inside a bounded for-loop, then prints [TEST_CASE_COMPLETED] and triggers a BREAKPOINT. Your job is ONLY to generate per-test-case helper_functions and test_logic bodies that plug into this skeleton. Target environment: Zephyr RTOS (mps2/an385, QEMU). Single-threaded execution.
Constraints:
1. Concurrency: **NO BLOCKING CALLS** on IPC/Sync objects (Pipe, MsgQ, Sem). This causes DEADLOCK in single-threaded tests. **ALWAYS use K_NO_WAIT** for reads/takes.
2. APIs: Prefer public `k_*` APIs. Avoid internal `z_*` symbols.
3. Memory: Static allocation preferred. No leaks.
4. Flow: No infinite loops. `test_logic` runs inside a bounded loop.
Input Policy: Use ONLY provided `FR_*` helpers to read from global `FUZZ_INPUT`. Deterministic mapping only (no rand/time).
Helper Signatures:
FR_Reader FR_init(const unsigned char* buf, size_t n); // Usage: FR_init(FUZZ_INPUT, MAX_FUZZ_INPUT_SIZE)
FR_next_range(FR_Reader* r, uint32_t min, uint32_t max) -> uint32_t;
FR_next_bytes(FR_Reader* r, unsigned char* out, size_t n) -> size_t;
FR_next_string(FR_Reader* r, size_t max_len) -> const char*;
Use modulo/clamping for valid ranges. `test_logic` runs in a bounded loop. NO infinite loops.
Reader Discipline: Init `FR_Reader` ONCE outside loop. Check `FR_remaining`.

==== USER PROMPT ====
Goal: Generate 1 fuzzing test case (JSON array) for the functions below and their key related APIs. Each item must include: name, description, api_category, helper_functions, test_logic.
Focus functions: k_spin_lock, k_spin_unlock, K_SPINLOCK, Function, k_spinlock

### Function k_spin_lock
Signature: ALWAYS_INLINE k_spinlock_key_t k_spin_lock ( struct k_spinlock * l );
Location: 
Cyclomatic: None Lines: None
Includes: none
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Parameters:
- l: struct k_spinlock * — A pointer to the spinlock to lock
Return values:
- : A key value that must be passed to k_spin_unlock() when the lock is released.
Related configs: none
Related APIs: none
Reference snippets:
- K_SPINLOCK (api:K_SPINLOCK:overview#c0) :: API: K_SPINLOCK Signature:
- Function K_SPINLOCK (func:K_SPINLOCK:lib/os/clock.c#c0) :: FUNC K_SPINLOCK ANY(1) file lib/os/clock.c:441-443 
- k_spinlock (api:k_spinlock:overview#c0) :: API: k_spinlock Signature:
- Type k_spinlock* (type:k_spinlock*:<includes>#c0) :: TYPE type k_spinlock* <includes> k_spinlock*
- Type k_spinlock (type:k_spinlock:kernel/sched.c#c0) :: TYPE struct k_spinlock kernel/sched.c struct k_spinlock
- Call k_sched_lock -> k_spin_lock (edge:k_sched_lock->k_spin_lock:kernel/sched.c:763#c0) :: Call: k_sched_lock -> k_spin_lock at kernel/sched.c:763

Official documentation (full):
Title: k_spin_lock
Signature: ALWAYS_INLINE k_spinlock_key_t k_spin_lock ( struct k_spinlock * l );
Parameters:
- l: struct k_spinlock * — A pointer to the spinlock to lock
Return values:
- : A key value that must be passed to k_spin_unlock() when the lock is released.

### Function k_spin_unlock
Signature: ALWAYS_INLINE void k_spin_unlock ( struct k_spinlock * l, k_spinlock_key_t key );
Location: 
Cyclomatic: None Lines: None
Includes: none
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Parameters:
- l: struct k_spinlock * — A pointer to the spinlock to release
- key: k_spinlock_key_t — The value returned from k_spin_lock() when this lock was acquired
Related configs: none
Related APIs: none

Official documentation (full):
Title: k_spin_unlock
Signature: ALWAYS_INLINE void k_spin_unlock ( struct k_spinlock * l, k_spinlock_key_t key );
Parameters:
- l: struct k_spinlock * — A pointer to the spinlock to release
- key: k_spinlock_key_t — The value returned from k_spin_lock() when this lock was acquired

### Function K_SPINLOCK
Signature: ANY(1)
Location: lib/os/clock.c:441-443
Cyclomatic: -1 Lines: -1
Includes: errno.h, stdbool.h, stddef.h, stdint.h, zephyr/internal/syscall_handler.h, zephyr/kernel.h, zephyr/sys/clock.h, zephyr/sys/timeutil.h, zephyr/syscalls/sys_clock_getrtoffset_mrsh.c, zephyr/syscalls/sys_clock_nanosleep_mrsh.c, zephyr/syscalls/sys_clock_settime_mrsh.c, zephyr/toolchain.h, zephyr/ztest.h, #include <zephyr/spinlock.h>
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Related configs: none
Related APIs: none
Reference snippets:
- K_SPINLOCK (api:K_SPINLOCK:overview#c0) :: API: K_SPINLOCK Signature:

Official documentation (full):
Title: K_SPINLOCK
Definition: #define K_SPINLOCK ( lck )
Includes:
#include <zephyr/spinlock.h>
Details (truncated):
for (k_spinlock_key_t __i K_SPINLOCK_ONEXIT = {}, __key = k_spin_lock(lck); !__i.key; k_spin_unlock((lck), __key), __i.key = 1) Guards a code block with the given spinlock, automatically acquiring the lock before executing the code block.
The lock will be released either when reaching the end of the code block or when leaving the block with K_SPINLOCK_BREAK.
Example usage:
K_SPINLOCK(&mylock) { ...execute statements with the lock held...
if (some_condition) { ...release the lock and leave the guarded section prematurely:
K_SPINLOCK_BREAK;
} ...execute statements with the lock held...
} Behind the scenes this pattern expands to a for-loop whose body is executed exactly once:
for (k_spinlock_key_t key = k_spin_lock(&mylock); ...; k_spin_unlock(&mylock, key)) {
...
} Warning The code block must execute to its end or be left by calling K_SPINLOCK_BREAK. Otherwise, e.g. if exiting the block with a break, goto or return statement, the spinlock will not be released on exit.

### Function k_spinlock
Signature: #define K_SPINLOCK ( lck )
Location: 
Cyclomatic: None Lines: None
Includes: #include <zephyr/spinlock.h>
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Related configs: none
Related APIs: none
Reference snippets:
- k_spinlock (api:k_spinlock:overview#c0) :: API: k_spinlock Signature:

Official documentation (full):
Title: K_SPINLOCK
Definition: #define K_SPINLOCK ( lck )
Includes:
#include <zephyr/spinlock.h>
Details (truncated):
for (k_spinlock_key_t __i K_SPINLOCK_ONEXIT = {}, __key = k_spin_lock(lck); !__i.key; k_spin_unlock((lck), __key), __i.key = 1) Guards a code block with the given spinlock, automatically acquiring the lock before executing the code block.
The lock will be released either when reaching the end of the code block or when leaving the block with K_SPINLOCK_BREAK.
Example usage:
K_SPINLOCK(&mylock) { ...execute statements with the lock held...
if (some_condition) { ...release the lock and leave the guarded section prematurely:
K_SPINLOCK_BREAK;
} ...execute statements with the lock held...
} Behind the scenes this pattern expands to a for-loop whose body is executed exactly once:
for (k_spinlock_key_t key = k_spin_lock(&mylock); ...; k_spin_unlock(&mylock, key)) {
...
} Warning The code block must execute to its end or be left by calling K_SPINLOCK_BREAK. Otherwise, e.g. if exiting the block with a break, goto or return statement, the spinlock will not be released on exit.

Generation requirements (Zephyr):
1) Output strict JSON array.
2) `test_logic` must be non-blocking (use `K_NO_WAIT` to prevent deadlock).
3) Derive parameters from `FUZZ_INPUT` using `FR_*` helpers.
4) Use `__ASSERT` for checks. Clean up on failure.
5) Choose suitable `api_category`.9) JSON formatting MUST be valid: use double quotes, escape all newline characters as \n, and do NOT include code fences/backticks. No trailing commas.

Forbidden/limitations (Zephyr):
- Do NOT call Zephyr internal/private symbols (e.g., names starting with z_ or arch_).
- Do NOT include random(), srand(), time(), or platform-specific syscalls. All variability from FUZZ_INPUT.
- Do NOT define any symbols with FR_ prefix; these are reserved by the template.
