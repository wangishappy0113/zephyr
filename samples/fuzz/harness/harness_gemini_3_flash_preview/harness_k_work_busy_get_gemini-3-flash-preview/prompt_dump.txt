==== SYSTEM PROMPT ====
You are a Zephyr kernel and driver-level testing expert. Generate high-quality, compilable, and runnable fuzzing test cases for the target API. Ensure task lifecycle completeness, correct synchronization usage, memory safety, and minimal viable initialization. The harness template already provides a fixed skeleton: it reads fuzz input via FR_* helpers from the global FUZZ_INPUT array, runs test logic inside a bounded for-loop, then prints [TEST_CASE_COMPLETED] and triggers a BREAKPOINT. Your job is ONLY to generate per-test-case helper_functions and test_logic bodies that plug into this skeleton. Target environment: Zephyr RTOS (mps2/an385, QEMU). Single-threaded execution.
Constraints:
1. Concurrency: **NO BLOCKING CALLS** on IPC/Sync objects (Pipe, MsgQ, Sem). This causes DEADLOCK in single-threaded tests. **ALWAYS use K_NO_WAIT** for reads/takes.
2. APIs: Prefer public `k_*` APIs. Avoid internal `z_*` symbols.
3. Memory: Static allocation preferred. No leaks.
4. Flow: No infinite loops. `test_logic` runs inside a bounded loop.
Input Policy: Use ONLY provided `FR_*` helpers to read from global `FUZZ_INPUT`. Deterministic mapping only (no rand/time).
Helper Signatures:
FR_Reader FR_init(const unsigned char* buf, size_t n); // Usage: FR_init(FUZZ_INPUT, MAX_FUZZ_INPUT_SIZE)
FR_next_range(FR_Reader* r, uint32_t min, uint32_t max) -> uint32_t;
FR_next_bytes(FR_Reader* r, unsigned char* out, size_t n) -> size_t;
FR_next_string(FR_Reader* r, size_t max_len) -> const char*;
Use modulo/clamping for valid ranges. `test_logic` runs in a bounded loop. NO infinite loops.
Reader Discipline: Init `FR_Reader` ONCE outside loop. Check `FR_remaining`.

==== USER PROMPT ====
Goal: Generate 1 fuzzing test case (JSON array) for the functions below and their key related APIs. Each item must include: name, description, api_category, helper_functions, test_logic.
Focus functions: k_work_busy_get, k_spin_lock, work_busy_get_locked, k_work_cancel_sync, k_work_init

### Function k_work_busy_get
Signature: int(k_work*)
Location: kernel/work.c:169-177
Cyclomatic: -1 Lines: -1
Includes: errno.h, ksched.h, wait_q.h, zephyr/kernel.h, zephyr/kernel_structs.h, zephyr/logging/log.h, zephyr/spinlock.h, zephyr/sys/printk.h
Outgoing calls summary: <operator>.assignment(), k_spin_lock(), <operator>.addressOf(), work_busy_get_locked(), k_spin_unlock()
Incoming callers count: 0
Official docs (summary):
Parameters:
- work: const struct k_work * — pointer to the work item.
Return values:
- : a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, K_WORK_CANCELING, and K_WORK_FLUSHING.
Related configs: none
Related APIs: none
Reference snippets:
- Function k_work_busy_get (func:k_work_busy_get:kernel/work.c#c0) :: FUNC k_work_busy_get int(k_work*) file kernel/work.c:169-177 
- k_work_busy_get (api:k_work_busy_get:overview#c0) :: API: k_work_busy_get Signature: int k_work_busy_get ( const struct k_work * work );
- Type k_work_busy_get (type:k_work_busy_get:kernel/work.c#c0) :: TYPE type k_work_busy_get kernel/work.c k_work_busy_get
- Function Summary k_work_busy_get (funcsum:k_work_busy_get:kernel/work.c:169-177#c0) :: FUNC_SUMMARY k_work_busy_get Signature: int(k_work*) Location: kernel/work.c:169-177 Parameters: k_work* work Metrics: cyclomatic=-1 nloc=-1
- Call k_work_busy_get -> work_busy_get_locked (edge:k_work_busy_get->work_busy_get_locked:kernel/work.c:172#c0) :: Call: k_work_busy_get -> work_busy_get_locked at kernel/work.c:172
- Call k_work_busy_get -> <operator>.assignment (edge:k_work_busy_get-><operator>.assignment:kernel/work.c:171#c0) :: Call: k_work_busy_get -> <operator>.assignment at kernel/work.c:171

Official documentation (full):
Title: k_work_busy_get
Signature: int k_work_busy_get ( const struct k_work * work );
Parameters:
- work: const struct k_work * — pointer to the work item.
Return values:
- : a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, K_WORK_CANCELING, and K_WORK_FLUSHING.

### Function k_spin_lock
Signature: ALWAYS_INLINE k_spinlock_key_t k_spin_lock ( struct k_spinlock * l );
Location: 
Cyclomatic: None Lines: None
Includes: none
Outgoing calls summary: none
Incoming callers count: 0
Official docs (summary):
Parameters:
- l: struct k_spinlock * — A pointer to the spinlock to lock
Return values:
- : A key value that must be passed to k_spin_unlock() when the lock is released.
Related configs: none
Related APIs: none

Official documentation (full):
Title: k_spin_lock
Signature: ALWAYS_INLINE k_spinlock_key_t k_spin_lock ( struct k_spinlock * l );
Parameters:
- l: struct k_spinlock * — A pointer to the spinlock to lock
Return values:
- : A key value that must be passed to k_spin_unlock() when the lock is released.

### Function work_busy_get_locked
Signature: int(k_work*)
Location: kernel/work.c:164-167
Cyclomatic: -1 Lines: -1
Includes: errno.h, ksched.h, wait_q.h, zephyr/kernel.h, zephyr/kernel_structs.h, zephyr/logging/log.h, zephyr/spinlock.h, zephyr/sys/printk.h
Outgoing calls summary: <operator>.and(), flags_get(), <operator>.addressOf(), <operator>.indirectFieldAccess()
Incoming callers count: 3

### Function k_work_cancel_sync
Signature: bool(k_work*,k_work_sync*)
Location: kernel/work.c:570-603
Cyclomatic: -1 Lines: -1
Includes: errno.h, ksched.h, wait_q.h, zephyr/kernel.h, zephyr/kernel_structs.h, zephyr/logging/log.h, zephyr/spinlock.h, zephyr/sys/printk.h
Outgoing calls summary: kernel/include/zephyr/sys/__assert.h:__ASSERT_NO_MSG:ANY(1)(), kernel/include/zephyr/tracing/tracing_macros.h:SYS_PORT_TRACING_OBJ_FUNC_ENTER:ANY(4)(), <operator>.assignment(), <operator>.addressOf(), <operator>.indirectFieldAccess(), k_spin_lock(), kernel/include/stdbool.h:bool:ANY(0)(), <operator>.notEquals()
Incoming callers count: 0
Official docs (summary):
Parameters:
- work: struct k_work * — pointer to the work item.
- sync: struct k_work_sync * — pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.
Return values:
- : if work was pending (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled);
- : otherwise
Related configs: none
Related APIs: none

Official documentation (full):
Title: k_work_cancel_sync
Signature: bool k_work_cancel_sync ( struct k_work * work, struct k_work_sync * sync );
Parameters:
- work: struct k_work * — pointer to the work item.
- sync: struct k_work_sync * — pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.
Return values:
- : if work was pending (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled);
- : otherwise

### Function k_work_init
Signature: void(k_work*,k_work_handler_t)
Location: kernel/work.c:153-162
Cyclomatic: -1 Lines: -1
Includes: errno.h, ksched.h, wait_q.h, zephyr/kernel.h, zephyr/kernel_structs.h, zephyr/logging/log.h, zephyr/spinlock.h, zephyr/sys/printk.h
Outgoing calls summary: kernel/include/zephyr/sys/__assert.h:__ASSERT_NO_MSG:ANY(1)(), <operator>.assignment(), <operator>.indirection(), <operator>.cast(), <operator>.arrayInitializer(), kernel/include/zephyr/tracing/tracing_macros.h:SYS_PORT_TRACING_OBJ_INIT:ANY(3)()
Incoming callers count: 1
Official docs (summary):
Parameters:
- work: struct k_work * — the work structure to be initialized.
- handler: k_work_handler_t — the handler to be invoked by the work item.
Related configs: none
Related APIs: none
Reference snippets:
- Type k_work_init (type:k_work_init:kernel/work.c#c0) :: TYPE type k_work_init kernel/work.c k_work_init
- k_work_init (api:k_work_init:overview#c0) :: API: k_work_init Signature: void k_work_init ( struct k_work * work, k_work_handler_t handler );
- Call k_work_init -> <operator>.assignment (edge:k_work_init-><operator>.assignment:kernel/work.c:159#c0-5cd31db4) :: Call: k_work_init -> <operator>.assignment at kernel/work.c:159

Official documentation (full):
Title: k_work_init
Signature: void k_work_init ( struct k_work * work, k_work_handler_t handler );
Parameters:
- work: struct k_work * — the work structure to be initialized.
- handler: k_work_handler_t — the handler to be invoked by the work item.

Generation requirements (Zephyr):
1) Output strict JSON array.
2) `test_logic` must be non-blocking (use `K_NO_WAIT` to prevent deadlock).
3) Derive parameters from `FUZZ_INPUT` using `FR_*` helpers.
4) Use `__ASSERT` for checks. Clean up on failure.
5) Choose suitable `api_category`.9) JSON formatting MUST be valid: use double quotes, escape all newline characters as \n, and do NOT include code fences/backticks. No trailing commas.

Forbidden/limitations (Zephyr):
- Do NOT call Zephyr internal/private symbols (e.g., names starting with z_ or arch_).
- Do NOT include random(), srand(), time(), or platform-specific syscalls. All variability from FUZZ_INPUT.
- Do NOT define any symbols with FR_ prefix; these are reserved by the template.
